# ProofMode Verification Server Requirements

## Executive Summary

The ProofMode Verification Server is a Cloudflare Workers-based API that validates cryptographic proof manifests generated by the OpenVine mobile app. It verifies PGP signatures, device attestation tokens, and analyzes human activity patterns to assign trust levels to videos.

**Technology Stack**: Cloudflare Workers + OpenPGP.js + R2 Storage
**Primary Function**: Validate ProofManifest authenticity and assign verification levels
**Response Time Target**: <500ms per verification request

---

## 1. API Endpoints

### **POST /verify**

Verify a ProofManifest and return verification results.

**Request Body**:
```json
{
  "proofManifest": {
    "sessionId": "uuid-string",
    "challengeNonce": "random-challenge-string",
    "vineSessionStart": "2025-11-10T12:00:00.000Z",
    "vineSessionEnd": "2025-11-10T12:00:06.500Z",
    "segments": [
      {
        "segmentId": "uuid-string",
        "startTime": "2025-11-10T12:00:00.000Z",
        "endTime": "2025-11-10T12:00:06.000Z",
        "frameHashes": ["sha256-hash-1", "sha256-hash-2", ...],
        "frameTimestamps": ["2025-11-10T12:00:00.033Z", ...],
        "sensorData": {
          "timestamp": "2025-11-10T12:00:00.000Z",
          "accelerometer": {"x": 0.1, "y": 0.2, "z": 9.8},
          "gyroscope": {"x": 0.01, "y": 0.02, "z": 0.01},
          "magnetometer": {"x": 25.3, "y": -12.1, "z": 48.5}
        }
      }
    ],
    "pauseProofs": [
      {
        "pauseId": "uuid-string",
        "startTime": "2025-11-10T12:00:03.000Z",
        "endTime": "2025-11-10T12:00:04.000Z",
        "sensorSnapshots": [...]
      }
    ],
    "interactions": [
      {
        "type": "start_recording",
        "timestamp": "2025-11-10T12:00:00.000Z",
        "data": {}
      }
    ],
    "finalVideoHash": "sha256-hash-of-final-video",
    "deviceAttestation": {
      "token": "base64-attestation-token",
      "platform": "iOS",
      "deviceId": "device-identifier",
      "isHardwareBacked": true,
      "createdAt": "2025-11-10T12:00:00.000Z",
      "challenge": "random-challenge-string",
      "metadata": {
        "attestationType": "app_attest"
      }
    },
    "pgpSignature": {
      "signature": "-----BEGIN PGP SIGNATURE-----\n...\n-----END PGP SIGNATURE-----",
      "publicKeyFingerprint": "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234",
      "signedAt": "2025-11-10T12:00:06.500Z"
    }
  },
  "publicKey": "-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----"
}
```

**Response Body**:
```json
{
  "isValid": true,
  "verificationLevel": "verified_mobile",
  "verificationDetails": {
    "pgpSignatureValid": true,
    "deviceAttestationValid": true,
    "deviceAttestationType": "app_attest",
    "isHardwareBacked": true,
    "humanActivityConfidence": 0.92,
    "humanLikely": true,
    "frameIntegrityCheck": "passed",
    "timelineConsistency": "passed"
  },
  "confidenceScore": 0.95,
  "warnings": [],
  "errors": [],
  "verifiedAt": "2025-11-10T12:05:00.000Z"
}
```

**Verification Levels** (from highest to lowest trust):
- `verified_mobile`: Hardware-backed mobile attestation + valid PGP signature + high human confidence
- `verified_web`: Web-based verification (no hardware attestation) + valid PGP signature
- `basic_proof`: Valid PGP signature only (no attestation or failed human activity check)
- `unverified`: Failed verification (invalid signature or attestation)

**HTTP Status Codes**:
- `200 OK`: Verification completed successfully
- `400 Bad Request`: Invalid request body or malformed manifest
- `422 Unprocessable Entity`: Verification failed (returns details in response)
- `500 Internal Server Error`: Server-side error during verification

---

## 2. Core Verification Components

### **2.1 PGP Signature Verification**

**Purpose**: Verify the ProofManifest has not been tampered with after generation.

**Implementation Requirements**:
1. **Library**: Use `openpgp@5.11.1` (latest stable OpenPGP.js)
2. **Process**:
   - Parse PGP public key from request
   - Extract PGP signature from `pgpSignature.signature`
   - Serialize ProofManifest to canonical JSON (same format as mobile app)
   - Verify signature using OpenPGP.js `verify()` method
   - Check signature fingerprint matches `pgpSignature.publicKeyFingerprint`

**Signature Format**: Clearsign format (armored PGP signature)

**Example Code** (TypeScript):
```typescript
import * as openpgp from 'openpgp';

async function verifyPGPSignature(
  manifestJson: string,
  signature: string,
  publicKeyArmored: string
): Promise<boolean> {
  try {
    // Parse public key
    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });

    // Read signed message
    const signedMessage = await openpgp.readCleartextMessage({
      cleartextMessage: signature
    });

    // Verify signature
    const verificationResult = await openpgp.verify({
      message: signedMessage,
      verificationKeys: publicKey
    });

    const { verified } = verificationResult.signatures[0];
    await verified; // Wait for verification promise

    return true;
  } catch (e) {
    console.error('PGP verification failed:', e);
    return false;
  }
}
```

**Validation Checks**:
- ✅ Signature cryptographically valid
- ✅ Signature fingerprint matches public key
- ✅ Signed data matches manifest content (no tampering)
- ⚠️ Signature timestamp is reasonable (<24 hours old)

---

### **2.2 Device Attestation Validation**

**Purpose**: Verify the video was captured on a genuine, untampered device.

#### **2.2.1 iOS App Attest Validation**

**Attestation Token Format**: Base64-encoded App Attest token (hardware-backed)

**Validation Process**:
1. **Decode token** from base64
2. **Validate challenge** matches `challengeNonce` in manifest
3. **Verify token signature** using Apple's public keys
4. **Check device integrity** verdict (MEETS_BASIC_INTEGRITY or higher)
5. **Verify timestamp** (token created within reasonable time of recording)

**Apple Documentation**: https://developer.apple.com/documentation/devicecheck/validating_apps_that_connect_to_your_server

**Validation Libraries**:
- Use `@apple/app-attest-verifier` (npm package) or manual implementation
- Fetch Apple's root certificates from: https://www.apple.com/certificateauthority/

**Example Code**:
```typescript
async function verifyAppAttest(
  attestation: DeviceAttestation,
  challenge: string
): Promise<{ valid: boolean; hardwareBacked: boolean }> {
  try {
    // Decode attestation token
    const tokenBuffer = Buffer.from(attestation.token, 'base64');

    // Validate challenge matches
    if (attestation.challenge !== challenge) {
      return { valid: false, hardwareBacked: false };
    }

    // Verify token with Apple's attestation service
    // (Implementation depends on chosen library)
    const isValid = await validateAppleAttestation(tokenBuffer, challenge);

    return {
      valid: isValid,
      hardwareBacked: attestation.isHardwareBacked
    };
  } catch (e) {
    console.error('App Attest validation failed:', e);
    return { valid: false, hardwareBacked: false };
  }
}
```

**Validation Checks**:
- ✅ Token format valid
- ✅ Challenge matches manifest nonce
- ✅ Token signature valid (Apple's keys)
- ✅ Device integrity verdict acceptable
- ✅ Token timestamp reasonable (<1 hour from session start)

#### **2.2.2 Android Play Integrity Validation**

**Attestation Token Format**: JWT (JSON Web Token) from Google Play Integrity API

**Validation Process**:
1. **Decode JWT token**
2. **Verify JWT signature** using Google's public keys
3. **Validate challenge** matches `challengeNonce`
4. **Check device integrity** verdict:
   - `MEETS_DEVICE_INTEGRITY`: Hardware-backed, production device
   - `MEETS_BASIC_INTEGRITY`: Software-backed or developer device
   - `MEETS_STRONG_INTEGRITY`: Highest level (Google-certified)
5. **Verify app authenticity** (package name, signing cert)

**Google Documentation**: https://developer.android.com/google/play/integrity/verdict

**Validation Process**:
```typescript
async function verifyPlayIntegrity(
  attestation: DeviceAttestation,
  challenge: string,
  expectedPackageName: string
): Promise<{ valid: boolean; hardwareBacked: boolean; verdict: string }> {
  try {
    // Decode JWT token
    const decodedToken = jwt.decode(attestation.token, { complete: true });

    // Verify JWT signature with Google's keys
    const publicKeys = await fetchGooglePublicKeys();
    const isValid = await verifyJWT(attestation.token, publicKeys);

    if (!isValid) {
      return { valid: false, hardwareBacked: false, verdict: 'INVALID_SIGNATURE' };
    }

    const payload = decodedToken.payload;

    // Validate challenge
    if (payload.requestDetails?.nonce !== challenge) {
      return { valid: false, hardwareBacked: false, verdict: 'CHALLENGE_MISMATCH' };
    }

    // Check device integrity verdict
    const verdict = payload.deviceIntegrity?.deviceRecognitionVerdict[0];
    const hardwareBacked = verdict === 'MEETS_DEVICE_INTEGRITY' ||
                          verdict === 'MEETS_STRONG_INTEGRITY';

    // Validate app authenticity
    if (payload.appIntegrity?.packageName !== expectedPackageName) {
      return { valid: false, hardwareBacked, verdict: 'PACKAGE_MISMATCH' };
    }

    return {
      valid: true,
      hardwareBacked,
      verdict
    };
  } catch (e) {
    console.error('Play Integrity validation failed:', e);
    return { valid: false, hardwareBacked: false, verdict: 'ERROR' };
  }
}
```

**Validation Checks**:
- ✅ JWT format valid
- ✅ JWT signature valid (Google's keys)
- ✅ Challenge matches manifest nonce
- ✅ Device integrity verdict acceptable
- ✅ App package name matches `com.openvine.mobile`
- ✅ Token timestamp reasonable (<1 hour from session start)

#### **2.2.3 Fallback Attestation Handling**

**Mock Attestation Format**: `MOCK_ATTESTATION_IOS_<base64-hash>` or `MOCK_ATTESTATION_ANDROID_<base64-hash>`

**Handling**:
- Recognize mock format (starts with `MOCK_ATTESTATION_`)
- Set `deviceAttestationValid: false`
- Set `isHardwareBacked: false`
- Downgrade verification level to `basic_proof`
- Log warning but don't fail verification entirely

---

### **2.3 Human Activity Pattern Analysis**

**Purpose**: Detect automated/bot-generated content vs human-captured videos.

**Input Data**:
- Sensor readings (accelerometer, gyroscope, magnetometer)
- User interactions (touch events, start/stop timing)
- Recording patterns (pauses, segment timing)
- Frame capture irregularities

**Analysis Algorithms**:

#### **2.3.1 Sensor Pattern Analysis**

**Human Characteristics**:
- **Accelerometer variability**: Humans have natural hand shake/movement (variance > 0.01 m/s²)
- **Gyroscope changes**: Natural rotation during recording (not perfectly static)
- **Magnetometer readings**: Realistic environmental magnetic field values
- **Pattern irregularity**: Human movements are non-periodic and unpredictable

**Bot Characteristics**:
- **Zero sensor variation**: All zeros or perfectly static values
- **Periodic patterns**: Perfectly regular sine wave patterns
- **Unrealistic values**: Sensor values outside physical limits
- **Perfect timing**: Recording starts/stops on exact millisecond boundaries

**Example Code**:
```typescript
function analyzeSensorPatterns(segments: RecordingSegment[]): {
  humanLikely: boolean;
  confidence: number;
  reasons: string[];
} {
  const reasons: string[] = [];
  let humanScore = 0;

  for (const segment of segments) {
    if (!segment.sensorData) continue;

    const { accelerometer, gyroscope } = segment.sensorData;

    // Check accelerometer variance (human hand shake)
    const accelVariance = Math.sqrt(
      accelerometer.x ** 2 + accelerometer.y ** 2 + accelerometer.z ** 2
    );

    if (accelVariance > 0.01) {
      humanScore += 1;
      reasons.push('Natural hand movement detected');
    } else if (accelVariance === 0) {
      humanScore -= 2;
      reasons.push('Suspicious: Zero accelerometer movement');
    }

    // Check gyroscope variation (rotation)
    const gyroVariance = Math.sqrt(
      gyroscope.x ** 2 + gyroscope.y ** 2 + gyroscope.z ** 2
    );

    if (gyroVariance > 0.005) {
      humanScore += 1;
      reasons.push('Natural rotation detected');
    }
  }

  const confidence = Math.min(1.0, Math.max(0.0, humanScore / (segments.length * 2)));

  return {
    humanLikely: confidence > 0.5,
    confidence,
    reasons
  };
}
```

#### **2.3.2 Timing Pattern Analysis**

**Human Characteristics**:
- **Recording duration variance**: Humans don't record exactly 6.000s every time
- **Reaction time**: Start/stop timing has natural delay (100-300ms variance)
- **Pause patterns**: Pauses are irregular in timing and frequency
- **Frame timing jitter**: Natural camera frame capture variance

**Bot Characteristics**:
- **Exact durations**: Every video exactly 6000ms
- **Perfect timing**: Start/stop on exact milliseconds
- **No pauses**: No natural pauses or exactly timed pauses
- **Frame regularity**: Perfectly spaced frame capture

**Example Code**:
```typescript
function analyzeTimingPatterns(manifest: ProofManifest): {
  humanLikely: boolean;
  confidence: number;
  reasons: string[];
} {
  const reasons: string[] = [];
  let humanScore = 0;

  // Check session duration variance
  const duration = new Date(manifest.vineSessionEnd).getTime() -
                  new Date(manifest.vineSessionStart).getTime();

  const durationVariance = Math.abs(duration - 6000); // Expected ~6s
  if (durationVariance > 50) {
    humanScore += 1;
    reasons.push('Natural duration variance');
  } else if (durationVariance < 5) {
    humanScore -= 1;
    reasons.push('Suspicious: Exact duration timing');
  }

  // Check pause patterns
  if (manifest.pauseProofs.length > 0) {
    const pauseDurations = manifest.pauseProofs.map(p =>
      new Date(p.endTime).getTime() - new Date(p.startTime).getTime()
    );

    const pauseVariance = standardDeviation(pauseDurations);
    if (pauseVariance > 100) {
      humanScore += 1;
      reasons.push('Natural pause timing variance');
    }
  }

  // Check interaction timing
  const interactionTimestamps = manifest.interactions.map(i =>
    new Date(i.timestamp).getTime()
  );

  const hasMillisecondPrecision = interactionTimestamps.some(t => t % 1000 !== 0);
  if (hasMillisecondPrecision) {
    humanScore += 1;
    reasons.push('Natural millisecond timing');
  }

  const confidence = Math.min(1.0, Math.max(0.0, humanScore / 3));

  return {
    humanLikely: confidence > 0.5,
    confidence,
    reasons
  };
}
```

#### **2.3.3 Overall Confidence Scoring**

**Confidence Score Calculation**:
```typescript
function calculateConfidenceScore(
  pgpValid: boolean,
  attestationValid: boolean,
  hardwareBacked: boolean,
  sensorAnalysis: { confidence: number },
  timingAnalysis: { confidence: number }
): number {
  let score = 0;

  // Base cryptographic verification (40% weight)
  if (pgpValid) score += 0.40;

  // Device attestation (30% weight)
  if (attestationValid && hardwareBacked) score += 0.30;
  else if (attestationValid) score += 0.15;

  // Human activity patterns (30% weight)
  const humanConfidence = (sensorAnalysis.confidence + timingAnalysis.confidence) / 2;
  score += humanConfidence * 0.30;

  return Math.min(1.0, score);
}
```

**Verification Level Assignment**:
```typescript
function determineVerificationLevel(
  pgpValid: boolean,
  attestationValid: boolean,
  hardwareBacked: boolean,
  humanLikely: boolean,
  confidenceScore: number
): string {
  if (!pgpValid) {
    return 'unverified';
  }

  if (attestationValid && hardwareBacked && humanLikely && confidenceScore > 0.8) {
    return 'verified_mobile';
  }

  if (attestationValid && !hardwareBacked && pgpValid) {
    return 'verified_web';
  }

  if (pgpValid) {
    return 'basic_proof';
  }

  return 'unverified';
}
```

---

## 3. Data Storage Requirements

### **3.1 Cloudflare R2 Storage**

**Purpose**: Cache verification results and public keys for performance.

**Buckets**:
- `proofmode-verification-cache`: Store verification results (TTL: 7 days)
- `proofmode-public-keys`: Store verified PGP public keys (TTL: 30 days)

**Cache Key Format**:
- Verification results: `verification/{manifestSessionId}`
- Public keys: `pubkey/{fingerprint}`

**Cache Strategy**:
1. Check R2 cache on verification request
2. If cache hit and < 24 hours old, return cached result
3. If cache miss, perform full verification
4. Store result in R2 with 7-day TTL

**Example Code**:
```typescript
async function getCachedVerification(
  env: Env,
  sessionId: string
): Promise<VerificationResult | null> {
  const key = `verification/${sessionId}`;
  const cached = await env.VERIFICATION_CACHE.get(key, 'json');

  if (cached && cached.verifiedAt) {
    const age = Date.now() - new Date(cached.verifiedAt).getTime();
    if (age < 24 * 60 * 60 * 1000) { // < 24 hours
      return cached as VerificationResult;
    }
  }

  return null;
}

async function cacheVerification(
  env: Env,
  sessionId: string,
  result: VerificationResult
): Promise<void> {
  const key = `verification/${sessionId}`;
  await env.VERIFICATION_CACHE.put(key, JSON.stringify(result), {
    expirationTtl: 7 * 24 * 60 * 60 // 7 days
  });
}
```

---

## 4. Performance Requirements

**Target Metrics**:
- **Response Time**: <500ms for verification request
- **Cache Hit Rate**: >80% for repeated verification requests
- **Concurrent Requests**: Handle 100 req/s without degradation
- **Error Rate**: <1% failed verifications due to server errors

**Optimization Strategies**:
1. **R2 Caching**: Cache verification results for 24 hours
2. **Parallel Processing**: Run PGP verification, attestation validation, and human analysis in parallel
3. **Early Returns**: Return cached results immediately if available
4. **Connection Pooling**: Reuse HTTP connections for Apple/Google validation

---

## 5. Error Handling

**Error Categories**:

### **5.1 Client Errors (400-499)**

**400 Bad Request**:
- Missing required fields in ProofManifest
- Invalid JSON format
- Invalid PGP signature format
- Invalid attestation token format

**Example Response**:
```json
{
  "error": "Invalid request",
  "details": "Missing required field: pgpSignature.signature",
  "code": "MISSING_FIELD"
}
```

**422 Unprocessable Entity**:
- Verification failed (invalid signature, attestation, etc.)
- Returns detailed failure reasons

**Example Response**:
```json
{
  "isValid": false,
  "verificationLevel": "unverified",
  "verificationDetails": {
    "pgpSignatureValid": false,
    "deviceAttestationValid": true,
    "humanActivityConfidence": 0.45
  },
  "errors": [
    "PGP signature verification failed: Invalid signature",
    "Human activity confidence below threshold (0.45 < 0.50)"
  ]
}
```

### **5.2 Server Errors (500-599)**

**500 Internal Server Error**:
- OpenPGP.js library failure
- Apple/Google attestation service unreachable
- R2 storage failure

**Example Response**:
```json
{
  "error": "Internal server error",
  "details": "Failed to verify attestation: Network timeout",
  "code": "ATTESTATION_TIMEOUT",
  "retryable": true
}
```

---

## 6. Security Considerations

**Attack Vectors to Defend Against**:

### **6.1 Replay Attacks**
**Defense**: Verify challenge nonce is unique and matches manifest session

### **6.2 Signature Forgery**
**Defense**: Use OpenPGP.js cryptographic verification (industry standard)

### **6.3 Attestation Token Replay**
**Defense**: Verify token timestamp is recent (<1 hour from session start)

### **6.4 Bot/Automated Content**
**Defense**: Human activity pattern analysis (sensor/timing irregularities)

### **6.5 Man-in-the-Middle Attacks**
**Defense**:
- Use HTTPS for all API communication
- Verify attestation tokens with Apple/Google public keys
- Validate challenge nonce prevents token reuse

### **6.6 DDoS Attacks**
**Defense**:
- Rate limiting (100 req/s per IP)
- Cloudflare DDoS protection (automatic)
- Cache verification results in R2 (reduce compute load)

---

## 7. Deployment Configuration

**Environment Variables**:
```bash
# Apple App Attest
APPLE_TEAM_ID=ABC123DEF4
APPLE_APP_ID=com.openvine.mobile

# Android Play Integrity
GOOGLE_CLOUD_PROJECT_ID=123456789012
ANDROID_PACKAGE_NAME=com.openvine.mobile

# Cloudflare R2
R2_VERIFICATION_CACHE_BUCKET=proofmode-verification-cache
R2_PUBLIC_KEYS_BUCKET=proofmode-public-keys

# Rate Limiting
MAX_REQUESTS_PER_SECOND=100
CACHE_TTL_SECONDS=604800  # 7 days
```

**Cloudflare Workers Configuration** (wrangler.toml):
```toml
name = "proofmode-verification-api"
main = "src/index.ts"
compatibility_date = "2025-11-10"

[[r2_buckets]]
binding = "VERIFICATION_CACHE"
bucket_name = "proofmode-verification-cache"

[[r2_buckets]]
binding = "PUBLIC_KEYS"
bucket_name = "proofmode-public-keys"

[vars]
ENVIRONMENT = "production"
MAX_REQUESTS_PER_SECOND = "100"
```

---

## 8. Testing Requirements

**Unit Tests**:
- ✅ PGP signature verification (valid/invalid signatures)
- ✅ iOS App Attest validation (valid/invalid/expired tokens)
- ✅ Android Play Integrity validation (valid/invalid verdicts)
- ✅ Human activity pattern detection (human vs bot patterns)
- ✅ Confidence score calculation edge cases
- ✅ Error handling for malformed requests

**Integration Tests**:
- ✅ End-to-end verification with real ProofManifests
- ✅ Caching behavior (cache hit/miss scenarios)
- ✅ Rate limiting enforcement
- ✅ Apple/Google attestation service integration

**Performance Tests**:
- ✅ Verification response time <500ms (99th percentile)
- ✅ Concurrent request handling (100 req/s sustained)
- ✅ Cache effectiveness (>80% hit rate)

---

## 9. Example Verification Flow

**Full Verification Process**:

```
1. Client POSTs ProofManifest + public key to /verify

2. Server checks R2 cache for existing verification
   - Cache HIT → Return cached result (fast path)
   - Cache MISS → Continue to verification

3. Server runs verification steps in parallel:

   a) PGP Signature Verification
      - Parse public key
      - Verify signature matches manifest
      - Check fingerprint matches

   b) Device Attestation Validation
      - iOS: Verify App Attest token with Apple
      - Android: Verify Play Integrity JWT with Google
      - Check challenge nonce matches

   c) Human Activity Analysis
      - Analyze sensor patterns (accelerometer, gyro)
      - Analyze timing patterns (pauses, duration)
      - Calculate confidence scores

4. Server calculates overall confidence score
   - Weight: 40% crypto, 30% attestation, 30% human
   - Assign verification level based on score

5. Server caches result in R2 (7-day TTL)

6. Server returns verification result to client
```

---

## 10. Success Metrics

**Production Readiness Checklist**:
- ✅ PGP signature verification working with OpenPGP.js
- ✅ iOS App Attest validation working with Apple APIs
- ✅ Android Play Integrity validation working with Google APIs
- ✅ Human activity pattern analysis producing confidence scores
- ✅ R2 caching reducing response time to <100ms for cached results
- ✅ Error handling covering all failure scenarios
- ✅ Rate limiting preventing abuse
- ✅ Unit tests covering >90% of code
- ✅ Integration tests with real ProofManifests passing
- ✅ Performance tests showing <500ms response time

**Monitoring & Alerts**:
- Track verification success rate (target: >95%)
- Monitor response time (target: p99 <500ms)
- Alert on error rate spike (>5% errors)
- Monitor cache hit rate (target: >80%)
- Track verification level distribution (expect majority `verified_mobile`)

---

## 11. Summary for Implementation Team

**What You Need to Build**:

1. **Cloudflare Workers API** with `/verify` endpoint
2. **PGP Verification** using OpenPGP.js library
3. **iOS App Attest Validation** using Apple's attestation service
4. **Android Play Integrity Validation** using Google's JWT verification
5. **Human Activity Analysis** algorithms (sensor + timing patterns)
6. **Confidence Scoring** algorithm to assign verification levels
7. **R2 Caching Layer** for performance optimization
8. **Error Handling** for all failure scenarios
9. **Rate Limiting** to prevent abuse
10. **Comprehensive Tests** (unit, integration, performance)

**Key Technologies**:
- **Cloudflare Workers** (serverless compute)
- **OpenPGP.js** (PGP signature verification)
- **Cloudflare R2** (object storage for caching)
- **TypeScript** (type-safe implementation)
- **JWT libraries** (Android Play Integrity token decoding)

**Estimated Complexity**: Medium (2-3 weeks for experienced Cloudflare Workers developer)

**Critical Success Factors**:
1. Correct PGP verification (don't accept tampered manifests)
2. Proper attestation validation (don't accept forged tokens)
3. Reasonable human detection (balance false positives/negatives)
4. Fast response times (<500ms via caching)
5. Robust error handling (graceful degradation)
